//Resetting Registers
LI R0 0
LI R1 0
LI R2 0
LI R3 0
LI R4 0
LI R5 0
LI R6 0
LI R7 0

//PROGRAM 2, LOADING operands
LD R0 4  //Low
LD R1 5  //high

MOV R2 R0 //low
MOV R3 R1  //high

LD R0 17  //1000 0000 mask
AND R0 R3   //sign
STR R0 10    //SIGN STORED IN 10
LD R0 18   //0111 1100 exp mask
AND R0 R3   //exponent  not shifted
SH R0 1 0   
SH R0 1 0   //aligning exponent bits for true value
STR R0 13    //STORING EXPONENT in case
MOV R1 R0   //R1 has EXPONENT value
LD R0 19   //0000 0011 mantissa high word 2 bits
AND R0 R3   //2 mantissa bits
STR R0 11    //MANTISSA HIGH BITS STORED IN 11
LD R0 20   //1111 1111 mantissa low bits
AND R0 R2  //mantissa low 8
STR R0 12   //MANTISSA LOW BITS STORED IN 12

MOV R2 R1   //saving copy of exponent
LD R0 21    //value of 22, 00010110
GT R1 R0    //is exp greater than 22?
BEQZ R1 2      //if not greater than 22, skip past this
J beginCond    //beginCond
J skip

beginCond:
LD R1 10    //loading sign, beginCond
BEQZ R1 2    //if sign is 0
J sign1      //sign is negative jump
LD R0 22     //0111 1111 max pos val high
STR R0 7      //STR MSW
LD R0 20      //1111 1111 max pos val low
STR R0 6      //STR LSW
J END         // JUMP TO END

sign1:
LD R0 17     //1000 0000 sign1, max neg val high
STR R0 7      //STR MSW
LI R0 0      //0000 0000 max neg val low
STR R0 6      //STR LSW
J END         // JUMP TO END

skip:
BEQZ R2 2    //skip location jump, checking if exponent is 0
J beginElse   //if neither of these scenarios jump to beginning of actual program
LI R0 0       //load val
STR R0 7
STR R0 6   //Store all 0's to MEM
J END      //JUMP TO END

beginElse:
LD R0 11   // beginElse, load in mantissas to do math (high)
MOV R3 R0 //Move to R3
LD R0 12   //low bits mantissa
MOV R2 R0  //Move to R2 low
LD R0 13   //exponent loading
MOV R1 R0   //moving exponent to R1
LI R7 0     //NOP clearing garbage flags
LD R0 23    //00000100  -> prepended 1 to mantissa bits mask
ADD R3 R0    //has mantissa high bits, with 1 prepend
LD R0 24     //00001111, value 15 for shift amount
SUB R1 R0    //Exponent - 15, result store in R1
SH R3 1 1    //SHR high word
SH R2 1 0    //SHR low
SH R3 1 1    //SHR high word
SH R2 1 0    //SHR low  (2 times to align radix)

LI R0 1    //Clear flags and decrement value; R1 has amt of times to shift
shift:
BEQZ R1 5  //if shift amount is 0, skip all this
SH R2 0 0    //shift left low word
SH R3 0 1    //shift left high word
SUB R1 R0 
J  shift    //line BEQZ

LI R7 0    //clear flags and placeholder
LD R0 10   //loading sign
BEQZ R0 2    //can skip bit inversion if 0 (positive)
J bitInv     //jump 2 lines down
J storingMem   

bitInv:
LI R6 1     //add 1 val
LD R1 20    //1111 1111 XOR mask
XOR R3 R1   //invert bits of high word
XOR R2 R1   //invert bits of low word
ADD R6 R2   //R6 has low word (with one added, overflow caught)
ADD R7 R3   //R3 is added with 0, such that overflow if needed can carry over
MOV R2 R6
MOV R3 R7   //moving back into R3 and R2 (high low) for consistency

storingMem:
MOV R0 R2   //storingMem, preparing to store low
STR R0 6     //storing LSW in mem[6]
MOV R0 R3   //high word
STR R0 7     //storing MSW in mem[7]
END:
LI R7 0     //END; ASSIGN DONE TO THIS INSTRUCTION




